## 动态规划

### 动态规划就是把抽象的事情具体化，具体到研究某一个状态的变化，动态规划中包含三个重要的概念，最优子结构、边界、状态转移公式。

[爬楼梯](#stairs)

[算出股票最佳买点](#buy)

[打家劫舍](#rob)

---
<span id="stairs"></span>
### 爬楼梯

>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？
注意：给定 n 是一个正整数。

思路：第 i 阶可以由两种方法得到：在第 (i−1) 阶后向上爬一阶，在第 (i−2) 阶后向上爬 2 阶,所以到达 i 阶的方法数可以有 (i-1)的方法数 加上 (i-2)的方法数

最优子结构：假设F(3)=F(2)+F(1)， 其中F(2)和F(1)是F(3)的最优子结构
边界： 当台阶只有一阶时只有一种方法，可以直接得出
状态转移公式： dp[i] = dp[i-1] + dp[i-2]

所以：
```javascript
climbStairs(n) {
    dp = []
    if (n == 0) {
        return 0
    }
    dp[1] = 1
    dp[2] = 2
    for (let i = 3; i <= n; i++) {
        dp[i] = dp[i-1] + dp[i-2]
    }
    return dp[n]
}
```
<span id="buy"></span>
### 算出股票最佳买点

>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。
如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。

>输入: [7,1,5,3,6,4]
输出: 5
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。

思路：加入 i 为当天买卖的日期，j 为当天的持有状态（0空仓，1持有），所以当天就要分情况去讨论:
第 i 天的最大受益,如果第 i 持有，那前一天（i-1）可能是持有情况，所以最大利润为前一天的最大利润dp[i - 1][1]， 也有可能是空仓后买进，所以最大利润为前一天的最大利润dp[i - 1][1]减去买入当天股票的价格price，又因为假如前一天空仓，从昨天到今天就不可能有收益，所以不用加 dp[i-1][0]，因为题中是说要最大利益的情况，所以取两者中的最大值，得出状态表达式为：dp[i][1] = Math.max(dp[i - 1][1], -price)

第 i 天的最大受益,如果第 i 空仓，那前一天（i-1）可能是空仓情况，所以最大利润为前一天的最大利润dp[i - 1][0]，也有可能是持有后卖出，所以最大利润为前一天的最大利润dp[i - 1][1]加上卖出当天股票的价格price，得出状态表达式为：dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + price[i])

状态转移公式： dp[i][1] = Math.max(dp[i - 1][1], -price[i])， dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + price[i])

```javascript
maximum(n) {
    const len = n.length
    // 创建固定长度的二维数组
    dp = Array.from(new Array(len), () => new Array(2))
    for (let i = 0; i <= n; i++) {
        if (i == 0) {
            dp[i][0] = 0
            dp[i][1] = -price
            continue
        }
        dp[i][1] = Math.max(dp[i - 1][1], -price[i])
        dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + price[i])
    }
    return dp[len - 1][0]
}
```

<span id="rob"></span>
### 打家劫舍
>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。
给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额

>输入: [1,2,3,1]
输出: 4
解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
     偷窃到的最高金额 = 1 + 3 = 4 。

思路：第 i 个房子获取的最大收益，要么是第 i 个房子的钱加上第 （i-2）个房子的最大收益，要么是第（i-1）的最大收益，所以取两者中的最大值,状态方程为dp[i] = Math.max(dp[i-2] + dp[i], dp[i-1])
```javascript
function(n) {
    const len = n.length
    if (len === 0) {
        dp[i] = 0
    }
    dp[1] = n[0]
    dp[2] = Math.max(n[0], n[1])
    for(let i = 3; i <= len; i++) {
        dp[i] = Math.max(dp[i-2] + n[i], dp[i-1])
    }
    retuen dp[len]
}
```